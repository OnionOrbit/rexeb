//! Install script generator
//!
//! Converts Debian maintainer scripts (preinst, postinst, prerm, postrm)
//! to Arch Linux .install script format

use regex::Regex;

use crate::error::Result;
use crate::models::{MaintainerScript, PackageMetadata};

/// Generator for Arch Linux .install scripts
pub struct InstallScriptGenerator<'a> {
    metadata: &'a PackageMetadata,
}

impl<'a> InstallScriptGenerator<'a> {
    /// Create a new install script generator
    pub fn new(metadata: &'a PackageMetadata) -> Self {
        Self { metadata }
    }

    /// Generate the .install script content
    /// Returns None if there are no scripts to convert
    pub fn generate(&self) -> Result<Option<String>> {
        let has_scripts = self.metadata.scripts.iter().any(|(_, content)| !content.is_empty());
        
        if !has_scripts {
            return Ok(None);
        }

        let mut output = String::new();

        // Add header
        output.push_str("# Maintainer script generated by rexeb\n");
        output.push_str("# Converted from Debian maintainer scripts\n\n");

        // Generate each function
        if let Some(content) = self.metadata.get_script(MaintainerScript::PreInst) {
            output.push_str(&self.generate_function("pre_install", content, false)?);
            output.push_str(&self.generate_function("pre_upgrade", content, true)?);
        }

        if let Some(content) = self.metadata.get_script(MaintainerScript::PostInst) {
            output.push_str(&self.generate_function("post_install", content, false)?);
            output.push_str(&self.generate_function("post_upgrade", content, true)?);
        }

        if let Some(content) = self.metadata.get_script(MaintainerScript::PreRm) {
            output.push_str(&self.generate_function("pre_remove", content, false)?);
        }

        if let Some(content) = self.metadata.get_script(MaintainerScript::PostRm) {
            output.push_str(&self.generate_function("post_remove", content, false)?);
        }

        Ok(Some(output))
    }

    /// Generate a single function
    fn generate_function(&self, name: &str, content: &str, is_upgrade: bool) -> Result<String> {
        let translated = self.translate_script(content, is_upgrade)?;
        
        Ok(format!(
            "{}() {{\n{}\n}}\n\n",
            name,
            self.indent(&translated, 2)
        ))
    }

    /// Translate Debian script content to Arch-compatible bash
    fn translate_script(&self, content: &str, is_upgrade: bool) -> Result<String> {
        let mut output = String::new();
        let lines: Vec<&str> = content.lines().collect();

        let mut skip_until_fi = 0;
        let mut in_case_block = false;

        for line in lines {
            let trimmed = line.trim();

            // Skip shebang
            if trimmed.starts_with("#!") {
                continue;
            }

            // Skip empty lines at the start
            if output.is_empty() && trimmed.is_empty() {
                continue;
            }

            // Handle case statements (common in Debian scripts)
            if trimmed.starts_with("case") && trimmed.contains("$1") {
                in_case_block = true;
                continue;
            }

            if in_case_block {
                if trimmed == "esac" {
                    in_case_block = false;
                    continue;
                }

                // Extract the action from case patterns
                if trimmed.ends_with(')') {
                    let pattern = trimmed.trim_end_matches(')');
                    
                    // For upgrade functions, only include upgrade-related patterns
                    if is_upgrade {
                        if !pattern.contains("upgrade") && !pattern.contains("1") {
                            skip_until_fi = 1;
                            continue;
                        }
                    } else {
                        // For install/remove, skip upgrade patterns
                        if pattern.contains("upgrade") {
                            skip_until_fi = 1;
                            continue;
                        }
                    }
                    continue;
                }

                if trimmed == ";;" {
                    skip_until_fi = 0;
                    continue;
                }

                if skip_until_fi > 0 {
                    continue;
                }
            }

            // Translate Debian-specific commands
            let translated_line = self.translate_line(line)?;
            output.push_str(&translated_line);
            output.push('\n');
        }

        // Clean up the output
        output = self.cleanup_script(&output);

        Ok(output)
    }

    /// Translate a single line of script
    fn translate_line(&self, line: &str) -> Result<String> {
        let mut line = line.to_string();

        // Replace dpkg commands
        lazy_static::lazy_static! {
            static ref DPKG_MAINTSCRIPT: Regex = Regex::new(
                r#"dpkg-maintscript-helper\s+(\w+)\s+([^\s]+)"#
            ).unwrap();
            
            static ref UPDATE_RC: Regex = Regex::new(
                r#"update-rc\.d\s+(\S+)\s+(\S+)"#
            ).unwrap();
            
            static ref INVOKE_RC: Regex = Regex::new(
                r#"invoke-rc\.d\s+(\S+)\s+(\S+)"#
            ).unwrap();
            
            static ref SYSTEMCTL: Regex = Regex::new(
                r#"systemctl\s+(enable|disable|start|stop|restart|reload)\s+(\S+)"#
            ).unwrap();
            
            static ref LDCONFIG: Regex = Regex::new(r#"ldconfig"#).unwrap();
            
            static ref UPDATE_DESKTOP_DB: Regex = Regex::new(
                r#"update-desktop-database"#
            ).unwrap();
            
            static ref UPDATE_MIME_DB: Regex = Regex::new(
                r#"update-mime-database"#
            ).unwrap();
            
            static ref GTK_UPDATE_ICON: Regex = Regex::new(
                r#"gtk-update-icon-cache"#
            ).unwrap();
        }

        // dpkg-maintscript-helper -> just comment it out or skip
        if DPKG_MAINTSCRIPT.is_match(&line) {
            return Ok(format!("# Skipped dpkg command: {}", line.trim()));
        }

        // update-rc.d -> systemctl
        if let Some(caps) = UPDATE_RC.captures(&line) {
            let service = &caps[1];
            let action = &caps[2];
            match action {
                "defaults" | "enable" => {
                    line = format!("systemctl enable {}.service 2>/dev/null || true", service);
                }
                "remove" | "disable" => {
                    line = format!("systemctl disable {}.service 2>/dev/null || true", service);
                }
                _ => {
                    line = format!("# update-rc.d {} {}", service, action);
                }
            }
        }

        // invoke-rc.d -> systemctl
        if let Some(caps) = INVOKE_RC.captures(&line) {
            let service = &caps[1];
            let action = &caps[2];
            line = format!("systemctl {} {}.service 2>/dev/null || true", action, service);
        }

        // Ensure ldconfig is present for library packages
        if LDCONFIG.is_match(&line) {
            line = "ldconfig".to_string();
        }

        // Desktop database update
        if UPDATE_DESKTOP_DB.is_match(&line) {
            line = "update-desktop-database -q || true".to_string();
        }

        // MIME database update
        if UPDATE_MIME_DB.is_match(&line) {
            line = "update-mime-database /usr/share/mime &>/dev/null || true".to_string();
        }

        // Icon cache update
        if GTK_UPDATE_ICON.is_match(&line) {
            line = "gtk-update-icon-cache -q -t -f /usr/share/icons/hicolor || true".to_string();
        }

        // Remove Debian-specific variable references
        line = line.replace("$DPKG_", "$PKG_");

        Ok(line)
    }

    /// Clean up the script output
    fn cleanup_script(&self, script: &str) -> String {
        let mut lines: Vec<&str> = script.lines().collect();
        
        // Remove trailing empty lines
        while lines.last().map_or(false, |l| l.trim().is_empty()) {
            lines.pop();
        }

        // Remove leading empty lines
        while lines.first().map_or(false, |l| l.trim().is_empty()) {
            lines.remove(0);
        }

        // Remove consecutive empty lines
        let mut result = Vec::new();
        let mut prev_empty = false;
        
        for line in lines {
            let is_empty = line.trim().is_empty();
            if is_empty && prev_empty {
                continue;
            }
            result.push(line);
            prev_empty = is_empty;
        }

        result.join("\n")
    }

    /// Add indentation to each line
    fn indent(&self, text: &str, spaces: usize) -> String {
        let indent = " ".repeat(spaces);
        text.lines()
            .map(|line| {
                if line.trim().is_empty() {
                    String::new()
                } else {
                    format!("{}{}", indent, line)
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_translate_systemctl() {
        let mut metadata = PackageMetadata::new("test", "1.0");
        metadata.scripts = HashMap::new();
        
        let generator = InstallScriptGenerator::new(&metadata);
        
        let line = "invoke-rc.d myservice start";
        let result = generator.translate_line(line).unwrap();
        assert!(result.contains("systemctl start myservice.service"));
    }

    #[test]
    fn test_translate_ldconfig() {
        let mut metadata = PackageMetadata::new("test", "1.0");
        metadata.scripts = HashMap::new();
        
        let generator = InstallScriptGenerator::new(&metadata);
        
        let line = "/sbin/ldconfig";
        let result = generator.translate_line(line).unwrap();
        assert!(result.contains("ldconfig"));
    }

    #[test]
    fn test_indent() {
        let metadata = PackageMetadata::new("test", "1.0");
        let generator = InstallScriptGenerator::new(&metadata);
        
        let text = "line1\nline2\n  line3";
        let result = generator.indent(text, 4);
        
        assert!(result.starts_with("    line1"));
    }
}